@page "/processes"
@using Slov89.PCStats.Data
@inject IMetricsService MetricsService
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer
@implements IAsyncDisposable

<PageTitle>Processes</PageTitle>

<h1>Processes</h1>

<div class="mb-3">
    <button type="button" class="btn btn-primary" @onclick="NavigateToPrevious" disabled="@(!CanNavigatePrevious())">
        <span class="bi bi-arrow-left"></span> Previous
    </button>
    
    @if (currentSnapshot != null)
    {
        <span class="ms-3 me-3 snapshot-info">
            <strong>Snapshot:</strong> @currentSnapshot.SnapshotTimestamp.ToString("yyyy-MM-dd HH:mm:ss")
            <span class="ms-3">
                <strong>CPU:</strong> @(currentSnapshot.TotalCpuUsage?.ToString("F2") ?? "N/A")%
            </span>
            <span class="ms-3">
                <strong>Memory:</strong> @((currentSnapshot.TotalMemoryUsageMb ?? 0).ToString("N0")) MB
            </span>
            <span class="ms-3">
                <strong>Available:</strong> @((currentSnapshot.TotalAvailableMemoryMb ?? 0).ToString("N0")) MB
            </span>
        </span>
    }
    
    <button type="button" class="btn btn-primary" @onclick="NavigateToNext" disabled="@(!CanNavigateNext())">
        Next <span class="bi bi-arrow-right"></span>
    </button>
    
    <button type="button" class="btn btn-success ms-2" @onclick="LoadLatestSnapshot">
        <span class="bi bi-arrow-clockwise"></span> Latest
    </button>
    
    @if (snapshotsLoaded && snapshots.Any())
    {
        <span class="ms-2 text-muted">(@(currentSnapshotIndex + 1) of @snapshots.Count)</span>
    }
</div>

@if (isLoading)
{
    <div class="text-center my-5">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading process data...</p>
    </div>
}
else if (hasError)
{
    <div class="alert alert-danger" role="alert">
        <h4 class="alert-heading">Error Loading Data</h4>
        <p>@errorMessage</p>
    </div>
}
else if (!processGroups.Any())
{
    <div class="alert alert-warning" role="alert">
        <h4 class="alert-heading">No Data Available</h4>
        <p>No process data found for this snapshot.</p>
        @if (currentSnapshot != null)
        {
            <p class="mb-0">
                <small>Snapshot ID: @currentSnapshot.SnapshotId | Timestamp: @currentSnapshot.SnapshotTimestamp.ToString("yyyy-MM-dd HH:mm:ss")</small>
            </p>
        }
    </div>
}
else
{
    <div class="card">
        <div class="card-body p-0">
            <div class="table-responsive">
                <table class="table table-dark table-hover mb-0 process-table">
                    <thead class="sticky-top">
                        <tr>
                            <th @onclick='() => SortBy("ProcessName")' style="cursor: pointer;">
                                Process Name @GetSortIcon("ProcessName")
                            </th>
                            <th @onclick='() => SortBy("CpuUsage")' style="cursor: pointer; text-align: right;">
                                CPU % @GetSortIcon("CpuUsage")
                            </th>
                            <th @onclick='() => SortBy("PrivateMemoryMb")' style="cursor: pointer; text-align: right;">
                                Private Memory (MB) @GetSortIcon("PrivateMemoryMb")
                            </th>
                            <th @onclick='() => SortBy("VramUsageMb")' style="cursor: pointer; text-align: right;">
                                VRAM (MB) @GetSortIcon("VramUsageMb")
                            </th>
                            <th @onclick='() => SortBy("ThreadCount")' style="cursor: pointer; text-align: right;">
                                Threads @GetSortIcon("ThreadCount")
                            </th>
                            <th @onclick='() => SortBy("HandleCount")' style="cursor: pointer; text-align: right;">
                                Handles @GetSortIcon("HandleCount")
                            </th>
                            <th @onclick='() => SortBy("FirstSeen")' style="cursor: pointer;">
                                First Seen @GetSortIcon("FirstSeen")
                            </th>
                            <th @onclick='() => SortBy("LastSeen")' style="cursor: pointer;">
                                Last Seen @GetSortIcon("LastSeen")
                            </th>
                            <th>Process Path</th>
                        </tr>
                    </thead>
                    <tbody>
                        @{
                            int rowIndex = 0;
                        }
                        @foreach (var group in GetSortedGroups())
                        {
                            var isExpanded = expandedProcesses.Contains(group.ProcessName);
                            var rowClass = rowIndex % 2 == 0 ? "even-row" : "odd-row";
                            rowIndex++;

                            <tr class="parent-row @rowClass" @onclick="() => ToggleExpand(group.ProcessName)" style="cursor: pointer;">
                                <td>
                                    <span class="expand-icon">@(isExpanded ? "▼" : "▶")</span>
                                    <strong>@group.ProcessName</strong>
                                    @if (group.Count > 1)
                                    {
                                        <span class="badge bg-secondary ms-2">@group.Count</span>
                                    }
                                </td>
                                <td style="text-align: right;">@($"{group.TotalCpuUsage:F2}")</td>
                                <td style="text-align: right;">@group.TotalPrivateMemoryMb.ToString("N0")</td>
                                <td style="text-align: right;">@group.TotalVramUsageMb.ToString("N0")</td>
                                <td style="text-align: right;">@group.TotalThreadCount.ToString("N0")</td>
                                <td style="text-align: right;">@group.TotalHandleCount.ToString("N0")</td>
                                <td>@group.FirstSeen.ToString("yyyy-MM-dd HH:mm:ss")</td>
                                <td>@group.LastSeen.ToString("yyyy-MM-dd HH:mm:ss")</td>
                                <td class="process-path">@group.ProcessPath</td>
                            </tr>

                            @if (isExpanded && group.Count > 1)
                            {
                                @foreach (var process in group.Processes)
                                {
                                    var childRowClass = rowIndex % 2 == 0 ? "even-row" : "odd-row";
                                    rowIndex++;

                                    <tr class="child-row @childRowClass">
                                        <td style="padding-left: 40px;">
                                            <span class="text-muted">PID: @process.Pid</span>
                                        </td>
                                        <td style="text-align: right;">@($"{process.CpuUsage ?? 0:F2}")</td>
                                        <td style="text-align: right;">@((process.PrivateMemoryMb ?? 0).ToString("N0"))</td>
                                        <td style="text-align: right;">@((process.VramUsageMb ?? 0).ToString("N0"))</td>
                                        <td style="text-align: right;">@((process.ThreadCount ?? 0).ToString("N0"))</td>
                                        <td style="text-align: right;">@((process.HandleCount ?? 0).ToString("N0"))</td>
                                        <td>@process.FirstSeen.ToString("yyyy-MM-dd HH:mm:ss")</td>
                                        <td>@process.LastSeen.ToString("yyyy-MM-dd HH:mm:ss")</td>
                                        <td class="process-path">@process.ProcessPath</td>
                                    </tr>
                                }
                            }
                        }
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="mt-3 text-muted">
        <small>Total: @processGroups.Count process groups, @processGroups.Sum(g => g.Count) individual processes</small>
    </div>
}

<style>
    .process-table {
        font-size: 0.9rem;
    }

    .process-table thead th {
        background-color: #1a1a1a;
        border-bottom: 2px solid #444;
        padding: 12px 8px;
        font-weight: 600;
        white-space: nowrap;
    }

    .process-table thead th:hover {
        background-color: #2a2a2a;
    }

    .process-table tbody td {
        padding: 10px 8px;
        vertical-align: middle;
        border-bottom: 1px solid #333;
    }

    .parent-row {
        font-weight: 500;
    }

    .parent-row:hover {
        background-color: #2a3a4a !important;
    }

    .child-row {
        font-size: 0.85rem;
    }

    .child-row:hover {
        background-color: #2a3a4a !important;
    }

    .even-row {
        background-color: #1e1e1e;
    }

    .odd-row {
        background-color: #252525;
    }

    .expand-icon {
        display: inline-block;
        width: 20px;
        color: #6c757d;
        font-size: 0.8rem;
    }

    .process-path {
        max-width: 300px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-size: 0.8rem;
        color: #888;
    }

    .table-responsive {
        max-height: calc(100vh - 250px);
        overflow-y: auto;
    }

    .sticky-top {
        position: sticky;
        top: 0;
        z-index: 10;
    }

    .snapshot-info {
        font-size: 0.95rem;
        vertical-align: middle;
    }
</style>

@code {
    private List<ProcessSnapshotDetail> processes = new();
    private List<ProcessGroup> processGroups = new();
    private List<SnapshotInfo> snapshots = new();
    private SnapshotInfo? currentSnapshot = null;
    private int currentSnapshotIndex = 0;
    private HashSet<string> expandedProcesses = new();
    private bool isLoading = true;
    private bool hasError = false;
    private string errorMessage = string.Empty;
    private string sortColumn = "PrivateMemoryMb";
    private bool sortDescending = true;
    private IJSObjectReference? jsModule;
    private bool snapshotsLoaded = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadLatestSnapshot();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./Components/Pages/Processes.razor.js");
            await jsModule.InvokeVoidAsync("setupKeyboardNavigation", DotNetObjectReference.Create(this));
        }
    }

    [JSInvokable]
    public async Task HandleKeyPress(string key)
    {
        if (key == "ArrowLeft")
        {
            await NavigateToPrevious();
        }
        else if (key == "ArrowRight")
        {
            await NavigateToNext();
        }
    }

    private async Task LoadLatestSnapshot()
    {
        isLoading = true;
        hasError = false;
        errorMessage = string.Empty;
        snapshotsLoaded = false; // Reset to force reload of snapshot list

        try
        {
            currentSnapshot = await MetricsService.GetLatestSnapshotInfoAsync();
            
            if (currentSnapshot == null)
            {
                hasError = true;
                errorMessage = "No snapshots found in the database. Please ensure the PCStats Service is running and collecting data.";
                isLoading = false;
                StateHasChanged();
                return;
            }

            await LoadCurrentSnapshotData();
            
            // Load all snapshots for navigation
            await EnsureSnapshotsLoaded();
        }
        catch (Exception ex)
        {
            hasError = true;
            errorMessage = $"Error loading latest snapshot: {ex.Message}";
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task EnsureSnapshotsLoaded()
    {
        if (snapshotsLoaded)
        {
            return;
        }

        try
        {
            snapshots = await MetricsService.GetAllSnapshotInfosAsync();
            
            if (currentSnapshot != null)
            {
                // Find current snapshot's index in the list
                currentSnapshotIndex = snapshots.FindIndex(s => s.SnapshotId == currentSnapshot.SnapshotId);
                if (currentSnapshotIndex == -1)
                {
                    currentSnapshotIndex = 0;
                }
            }
            
            snapshotsLoaded = true;
        }
        catch (Exception ex)
        {
            hasError = true;
            errorMessage = $"Error loading snapshot list: {ex.Message}";
        }
    }

    private async Task LoadCurrentSnapshotData()
    {
        if (currentSnapshot == null)
        {
            hasError = true;
            errorMessage = "No current snapshot selected.";
            isLoading = false;
            StateHasChanged();
            return;
        }

        isLoading = true;
        hasError = false;
        errorMessage = string.Empty;

        try
        {
            processes = await MetricsService.GetProcessSnapshotsByIdAsync(currentSnapshot.SnapshotId);
            
            // Group processes by name
            processGroups = processes
                .GroupBy(p => p.ProcessName)
                .Select(g => new ProcessGroup
                {
                    ProcessName = g.Key,
                    Processes = g.OrderBy(p => p.Pid).ToList(),
                    Count = g.Count(),
                    TotalCpuUsage = g.Sum(p => p.CpuUsage ?? 0),
                    TotalPrivateMemoryMb = g.Sum(p => p.PrivateMemoryMb ?? 0),
                    TotalVramUsageMb = g.Sum(p => p.VramUsageMb ?? 0),
                    TotalThreadCount = g.Sum(p => p.ThreadCount ?? 0),
                    TotalHandleCount = g.Sum(p => p.HandleCount ?? 0),
                    FirstSeen = g.Min(p => p.FirstSeen),
                    LastSeen = g.Max(p => p.LastSeen),
                    ProcessPath = g.First().ProcessPath ?? string.Empty
                })
                .ToList();
        }
        catch (Exception ex)
        {
            hasError = true;
            errorMessage = $"Error loading process data: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private bool CanNavigatePrevious()
    {
        return snapshotsLoaded && currentSnapshotIndex < snapshots.Count - 1;
    }

    private bool CanNavigateNext()
    {
        return snapshotsLoaded && currentSnapshotIndex > 0;
    }

    private async Task NavigateToPrevious()
    {
        await EnsureSnapshotsLoaded();
        
        if (CanNavigatePrevious())
        {
            currentSnapshotIndex++;
            currentSnapshot = snapshots[currentSnapshotIndex];
            StateHasChanged(); // Force UI update for counter
            await LoadCurrentSnapshotData();
        }
    }

    private async Task NavigateToNext()
    {
        await EnsureSnapshotsLoaded();
        
        if (CanNavigateNext())
        {
            currentSnapshotIndex--;
            currentSnapshot = snapshots[currentSnapshotIndex];
            StateHasChanged(); // Force UI update for counter
            await LoadCurrentSnapshotData();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (jsModule != null)
        {
            await jsModule.DisposeAsync();
        }
    }

    private void ToggleExpand(string processName)
    {
        if (expandedProcesses.Contains(processName))
        {
            expandedProcesses.Remove(processName);
        }
        else
        {
            expandedProcesses.Add(processName);
        }
    }

    private void SortBy(string column)
    {
        if (sortColumn == column)
        {
            sortDescending = !sortDescending;
        }
        else
        {
            sortColumn = column;
            sortDescending = true; // Always start with descending
        }
    }

    private string GetSortIcon(string column)
    {
        if (sortColumn != column)
            return "";

        return sortDescending ? "▼" : "▲";
    }

    private IEnumerable<ProcessGroup> GetSortedGroups()
    {
        var groups = processGroups.AsEnumerable();

        groups = sortColumn switch
        {
            "ProcessName" => sortDescending 
                ? groups.OrderByDescending(g => g.ProcessName) 
                : groups.OrderBy(g => g.ProcessName),
            "CpuUsage" => sortDescending 
                ? groups.OrderByDescending(g => g.TotalCpuUsage) 
                : groups.OrderBy(g => g.TotalCpuUsage),
            "PrivateMemoryMb" => sortDescending 
                ? groups.OrderByDescending(g => g.TotalPrivateMemoryMb) 
                : groups.OrderBy(g => g.TotalPrivateMemoryMb),
            "VramUsageMb" => sortDescending 
                ? groups.OrderByDescending(g => g.TotalVramUsageMb) 
                : groups.OrderBy(g => g.TotalVramUsageMb),
            "ThreadCount" => sortDescending 
                ? groups.OrderByDescending(g => g.TotalThreadCount) 
                : groups.OrderBy(g => g.TotalThreadCount),
            "HandleCount" => sortDescending 
                ? groups.OrderByDescending(g => g.TotalHandleCount) 
                : groups.OrderBy(g => g.TotalHandleCount),
            "FirstSeen" => sortDescending 
                ? groups.OrderByDescending(g => g.FirstSeen) 
                : groups.OrderBy(g => g.FirstSeen),
            "LastSeen" => sortDescending 
                ? groups.OrderByDescending(g => g.LastSeen) 
                : groups.OrderBy(g => g.LastSeen),
            _ => groups.OrderByDescending(g => g.TotalPrivateMemoryMb)
        };

        return groups;
    }

    private class ProcessGroup
    {
        public string ProcessName { get; set; } = string.Empty;
        public List<ProcessSnapshotDetail> Processes { get; set; } = new();
        public int Count { get; set; }
        public decimal TotalCpuUsage { get; set; }
        public long TotalPrivateMemoryMb { get; set; }
        public long TotalVramUsageMb { get; set; }
        public int TotalThreadCount { get; set; }
        public int TotalHandleCount { get; set; }
        public DateTime FirstSeen { get; set; }
        public DateTime LastSeen { get; set; }
        public string ProcessPath { get; set; } = string.Empty;
    }
}
